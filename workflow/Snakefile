include: "tools/Snakefile.smk"

report: "report/workflow.rst"

ruleorder:  load_GN > load_mSM > trial_selection > locaNMF > feature_concat > parcellate >  thresholding > feature_grouping > feature_calculation

from snakemake_tools import getKeys, hash_config



###   Output accumulation rules   ###

#rule paper:
    #input:
        #Fig 2: Timeseries Activity, Spatial Activity Maps, Frames

        #Fig 3: Framewise Decoding, Comparison FEatures: Framewise, Phasewide, Mean (Temporal + Across Parcel), Conf Matrizes, Class Coefs, Across Time
        #expand([f"results/paper/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/perf_all.feats.parcels.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids]),

        #Decoding performance over time across: parcellations, features
        #expand([f"results/paper/{dataset_id}/{subset_id}/{{feature}}/{'.'.join(aggr_conditions)}/performance_over_time_parcels.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  feature =  features), # (3a)
        #expand([f"results/paper/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/performance_over_time_features.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  parcellation = parcellations), # (3b)

#rule subdivided_svd:

#rule brain_alignment:

rule parcellation: 
    input:
        #Result of parcellations
        expand(f"results/data/{{session_run}}/{{parcellation}}/{{session_run}}/data.h5", session_run = session_runs,  parcellation = parcellations), #TODO add all session_run = session_runs+["All"]
        #Plot of parcellations
        expand(f"results/data/{{session_run}}/{{parcellation}}/visualization/combined_parcels.pdf", session_run = session_runs,  parcellation = parcellations)

rule conditions:
    input:
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(trial_conditions)}/b-maps/{{parcellation}}/all_cond_difference_b-maps.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                parcellation = parcellations)

rule feature:
    input:
        expand([f"results/data/{dataset_id}/{{parcellation}}/{subset_id}/Features/{{trial_conditions}}/{{feature}}/{{trial_conditions}}.{{feature}}.{config['export_type']}"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                parcellation = parcellations, trial_conditions = trial_conditions, feature =  features)
    output:
        dict = f"results/exports/feats_hash{hash_config(config)}.{config['export_type']}"
    params:
        iter = [session_runs, getKeys(parcellations), getKeys(trial_conditions), getKeys(features)],
        reorder = "feature" #TODO can you access rule name from script context?

    conda:
        "envs/environment.yaml"
    script:
        "scripts/aggregate_dict.py"


rule decode:
    input:
        #Decoding performance across: features, parcellation and both
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{parcellation}}_perf.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, ),
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}_perf.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    feature =  features, ),
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/all_perf.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids], ),

        #Plot Train/Test across time: on the same timepoints, on different timepoint
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/performance_over_time.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature =  features, ),
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/performance_matrix.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature =  features, decoder=decoders,),
        
        #Decoding performance over time across: parcellations, features
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}_performance_over_time.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    feature =  features, ),
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{parcellation}}_performance_over_time.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, ),
        
        #Confusion Matrix
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/confusion_matrix.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature =  features, decoder=decoders, ),
        
        #Plot coefs
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/model_coef_mean.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature =  features, decoder=decoders, ),

        #Plot clustered coefs
        #expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/CoefsAcrossTime_clustered.pdf"
        #                for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
        #            parcellation = parcellations, feature =  features, decoder=decoders, ),

        #Create models from clusters and test over time
        #expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/ClusturedModels_perf.pdf"
        #                for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
        #            parcellation = parcellations, feature =  features, decoder=decoders, ),


        ## Plot from df across aggregated datasets
        #expand(f"results/plots/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/perf_all.datasets.pdf", parcellation = parcellations, feature =  features, decoder=decoders),

rule decode_generalized:
    input:
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/{{feature}}/{{parcellation}}/{{decoder}}/from_{generalize_from}/ClusturedModels_perf.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature =  features, decoder=decoders),
        expand([f"results/data/{dataset_id}/{{parcellation}}/{subset_id}/Decoding/decoder/{'.'.join(aggr_conditions)}/{{feature}}/{{decoder}}/from_{generalize_from}/cluster_perf.pkl"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature =  features, decoder=decoders),

'''
rule decode:
    input:
        #Decoding performance across: features, parcellation and both
        expand([f"results/plots/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/perf_all.feats.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  parcellation = parcellations),
        expand([f"results/plots/{dataset_id}/{subset_id}/{{feature}}/{'.'.join(aggr_conditions)}/perf_all.parcels.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  feature =  features),
        expand([f"results/plots/{dataset_id}/{subset_id}/{'.'.join(aggr_conditions)}/perf_all.feats.parcels.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids]),

        #Plot Train/Test across time: on the same timepoints, on different timepoints
        expand([f"results/plots/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/{{feature}}/performance_over_time.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids] ,parcellation = parcellations, feature =  features),
        expand([f"results/plots/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/{{feature}}/{{decoder}}/performance_matrix.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids] ,parcellation = parcellations, feature =  features, decoder=decoders),
        
        #Decoding performance over time across: parcellations, features
        expand([f"results/plots/{dataset_id}/{subset_id}/{{feature}}/{'.'.join(aggr_conditions)}/performance_over_time_parcels.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  feature =  features),
        expand([f"results/plots/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/performance_over_time_features.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  parcellation = parcellations),
        
        #Confusion Matrix
        expand([f"results/plots/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/{{feature}}/{{decoder}}/confusion_matrix.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids] ,parcellation = parcellations, feature =  features, decoder=decoders),
        
        #Plot coefs
        expand([f"results/plots/{dataset_id}/{subset_id}/{{parcellation}}/{'.'.join(aggr_conditions)}/{{feature}}/{{decoder}}/model_coef_mean.pdf" for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],  parcellation = parcellations, feature =  features, decoder=decoders),
'''
        


rule load:
    input:
        expand("results/data/{session_run}/SVD/data.h5",session_run=session_runs)

rule biomarkers:
    input:
        expand([f"results/data/{dataset_id}/{{parcellation}}/{subset_id}/Decoding/rfe/{'.'.join(aggr_conditions)}/{{rfe_n}}/{{feature}}/circle_plot.pdf"
                        for dataset_id, subset_ids in session_runs.items() for subset_id in subset_ids],
                    parcellation = parcellations, feature = features, rfe_n = rfe_ns)






# The first rule is default
#TODO remove
rule decoding_performances:
    input:
        [ f"results/{config['output']['processed_dates']}/{parcellation}/{trials}/Decoding/decoder/{'.'.join(aggr_conditions)}/performances.pdf"
            for parcellation in parcellations
            for trials in selected_trials],
        #[ f"results/{'_'.join(subject_dates)}/{parcellation}/{trials}/Decoding/decoder/{'.'.join(aggr_conditions)}/{feature}/plots/performance.pdf"
        #    for parcellation in parcellations
        #    for trials in selected_trials
        #    for feature in features],
        [ f"results/plots/{config['output']['processed_dates']}/{trials}/Decoding/{'.'.join(aggr_conditions)}/{feature}/performances.pdf"
              for feature in features
               for trials in selected_trials],
    output:
        decoders = [ f"results/runs/{run_id}/features_{parcellation}_{trials}_{config['output']['processed_dates']}_{'.'.join(aggr_conditions)}_decoding_performances.pdf"
            for parcellation in parcellations
            for trials in selected_trials],
        #decoder = [ f"results/runs/{run_id}/Features/{'_'.join(subject_dates)}_{parcellation}_{trials}_{'.'.join(aggr_conditions)}_{feature}_performance.pdf"
        #    for parcellation in parcellations
        #    for trials in selected_trials
        #    for feature in features],
        parcellations = [ f"results/runs/{run_id}/parcellations_{feature}_{trials}_{config['output']['processed_dates']}_{'.'.join(aggr_conditions)}_decoding_performances.pdf"
            for feature in features
            for trials in selected_trials],
    log:
        f"results/runs/{run_id}/pipeline_entry.log"
    conda:
        "envs/environment.yaml"
    resources:
        mem_mb=lambda wildcards, attempt: mem_res(wildcards,attempt,4000,1000)
    script:
        "scripts/run_aggregation.py"


module loading:
    snakefile: "rules/loading.smk"
    config:  config | config['loading']

use rule * from loading

module processing:
    snakefile: "rules/processing.smk"
    config: config | config['processing']

use rule * from processing

module plotting:
    snakefile: "rules/plotting.smk"
    config: config | config['plotting']

use rule * from plotting
